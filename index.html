<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>RVM-3101 QR Scanner ‚Äî Production</title>
<style>
  /* ---- Layout & theme (polished, similar to your original) ---- */
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg,#667eea 0%, #764ba2 100%);
    min-height: 100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:20px;
  }
  .container {
    width:100%;
    max-width:980px;
    background:#fff;
    border-radius:18px;
    box-shadow:0 24px 60px rgba(0,0,0,0.28);
    padding:26px;
    display:grid;
    grid-template-columns: 1fr 360px;
    gap:20px;
    overflow:hidden;
  }

  /* Left column */
  .left { padding-right:6px; }
  .topbar { display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; }
  h1 { font-size:26px; color:#333; }
  .device-id { color:#666; font-size:13px; }

  .status-card {
    border-radius:12px;
    padding:18px;
    margin-bottom:16px;
    text-align:center;
    transition:all .25s ease;
    border:2px solid transparent;
  }
  .status-card.ready { background: linear-gradient(135deg,#667eea12,#764ba212); border-color:#667eea; }
  .status-card.scanning { background: linear-gradient(135deg,#ffd89b12,#19547b12); border-color:#ffa726; }
  .status-card.validating { background: linear-gradient(135deg,#a8edea12,#fed6e312); border-color:#4fc3f7; }
  .status-card.success { background: linear-gradient(135deg,#d4f8e820,#8fd3f420); border-color:#4caf50; }
  .status-card.error { background: linear-gradient(135deg,#fce4ec12,#f8bbd012); border-color:#f44336; }

  .status-icon { font-size:44px; margin-bottom:6px; }
  .status-text { font-weight:700; font-size:18px; color:#333; }
  .status-subtext { color:#666; font-size:13px; margin-top:6px; }

  #scanInput {
    width:100%;
    padding:18px;
    font-size:16px;
    border:3px solid #e9e9e9;
    border-radius:12px;
    margin-bottom:12px;
    text-align:center;
    letter-spacing:2px;
    font-weight:600;
  }
  #scanInput:focus { outline:none; border-color:#667eea; box-shadow:0 0 0 8px rgba(102,126,234,0.06); }
  #scanInput:disabled { opacity:.78; background:#fbfbfb; cursor:not-allowed; }

  .scan-history {
    background:#f8f9fa;
    border-radius:12px;
    padding:14px;
    max-height:520px;
    overflow:auto;
    margin-top:8px;
  }
  .scan-history h3 { display:flex; align-items:center; justify-content:space-between; margin-bottom:10px; font-size:16px; color:#333; }
  .clear-btn { background:#f44336; color:#fff; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:700; }
  .scan-item { background:#fff; padding:12px; border-radius:10px; box-shadow:0 6px 18px rgba(0,0,0,0.04); margin-bottom:10px; border-left:4px solid #667eea; }
  .scan-item.success { border-left-color:#4caf50; }
  .scan-item.error { border-left-color:#f44336; }
  .scan-code { font-weight:800; color:#667eea; margin-bottom:6px; display:block; }
  .scan-user { color:#4caf50; font-size:14px; margin-bottom:4px; }
  .scan-error { color:#f44336; font-size:14px; margin-bottom:4px; }
  .scan-time { color:#999; font-size:12px; }

  .stats { display:flex; justify-content:space-between; gap:10px; margin-top:12px; padding-top:12px; border-top:1px solid #eee; }
  .stat-item { text-align:center; flex:1; }
  .stat-value { font-size:26px; font-weight:800; color:#667eea; }
  .stat-label { font-size:12px; color:#999; margin-top:6px; }

  .loading-spinner { display:inline-block; width:18px; height:18px; border:3px solid #f3f3f3; border-top:3px solid #667eea; border-radius:50%; animation:spin 1s linear infinite; vertical-align:middle; margin-right:8px; }
  @keyframes spin { 0%{ transform:rotate(0) } 100% { transform:rotate(360deg) } }

  /* Right column (controls & debug) */
  .right { display:flex; flex-direction:column; gap:12px; }
  .card { background:#fff; padding:14px; border-radius:12px; box-shadow:0 6px 20px rgba(0,0,0,0.06); }
  .card .muted { color:#777; font-size:13px; margin-bottom:8px; }
  .btn { display:inline-block; padding:10px 12px; border-radius:8px; border:none; cursor:pointer; font-weight:700; }
  .btn.primary { background:#2196f3; color:#fff; }
  .btn.ghost { background:#f0f0f0; color:#333; }

  .small { font-size:13px; color:#666; margin-top:8px; }
  .code { font-family:monospace; font-size:12px; color:#333; background:#f3f4f6; padding:6px 8px; border-radius:6px; display:inline-block; }

  @media (max-width: 880px) {
    .container { grid-template-columns: 1fr; padding:18px; }
    .right { order:2; }
  }
</style>
</head>
<body>
  <div class="container" role="application" aria-label="RVM QR Scanner">
    <div class="left">
      <div class="topbar">
        <div>
          <h1>üéØ QR Scanner</h1>
          <div class="device-id">Device: <strong>RVM-3101</strong></div>
        </div>
        <div style="text-align:right">
          <div style="font-size:13px;color:#666">Local WS: <span id="wsState" style="font-weight:700;color:#d32f2f">disconnected</span></div>
          <div style="font-size:12px;color:#999;margin-top:6px">Auto-reset: cycle-complete (agent)</div>
        </div>
      </div>

      <div id="statusCard" class="status-card ready" aria-live="polite">
        <div class="status-icon">üì±</div>
        <div class="status-text">Ready to Scan</div>
        <div class="status-subtext">Place QR code near scanner</div>
      </div>

      <input id="scanInput" type="text" placeholder="Scan QR Code Here..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" aria-label="QR scanner input" />

      <div class="scan-history" aria-live="polite">
        <h3>
          Recent Scans
          <button class="clear-btn" onclick="clearHistory()" title="Clear scan history">Clear</button>
        </h3>
        <div id="scanHistoryList">
          <div class="no-scans" style="color:#999;padding:18px;text-align:center">No scans yet. Start scanning QR codes!</div>
        </div>

        <div class="stats" aria-hidden="false">
          <div class="stat-item">
            <div class="stat-value" id="totalScans">0</div>
            <div class="stat-label">TOTAL</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="successScans">0</div>
            <div class="stat-label">SUCCESS</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="failedScans">0</div>
            <div class="stat-label">FAILED</div>
          </div>
        </div>
      </div>
    </div>

    <div class="right">
      <div class="card" role="region" aria-label="Controls">
        <div style="font-weight:700;margin-bottom:6px">Scanner Controls & Debug</div>
        <div class="muted">For local testing / diagnostic only</div>

        <div style="display:flex;gap:8px;margin-top:10px">
          <button class="btn primary" onclick="simulateValid()">Simulate Valid QR</button>
          <button class="btn ghost" onclick="simulateInvalid()">Simulate Invalid</button>
        </div>

        <div class="small" style="margin-top:12px">Local WS port: <span class="code">3001</span></div>
        <div class="small" style="margin-top:6px">Reset topic (agent): <span class="code">resetReady</span></div>
      </div>

      <div class="card" role="region" aria-label="Last result">
        <div style="font-weight:700;margin-bottom:8px">Last Event</div>
        <div id="lastResult" style="color:#333;font-size:14px">‚Äî</div>
      </div>

      <div class="card" role="region" aria-label="Connection status">
        <div style="font-weight:700;margin-bottom:8px">Connection</div>
        <div style="color:#666">WebSocket status: <strong id="wsStatusText">not connected</strong></div>
        <div id="uiClientCount" style="margin-top:8px;color:#999">UI clients: 0</div>
      </div>
    </div>
  </div>

  <script>
  /**************************************************************************
   * qr-scanner-prod.html
   *
   * Production-ready scanner UI that:
   * - Captures keyboard-emulated QR scanner input
   * - Posts validation requests to backend
   * - Connects to agent's local WebSocket (ws://localhost:3001)
   * - Resets (re-enables input + focus) on agent "resetReady" or "cycleComplete"
   * - Has watchdog to force recovery if something gets stuck
   *
   * Requirements:
   * - Agent must run with local WebSocket server on ws://localhost:3001 and send:
   *     { type: 'resetReady' }  (or) { type: 'cycleComplete', payload: {...} }
   *
   **************************************************************************/

  (function () {
    // ---------- CONFIG ----------
    const CONFIG = {
      backend: {
        url: 'https://rebit-api.ceewen.xyz',
        validateEndpoint: '/api/rvm/RVM-3101/qr/validate',
        timeoutMs: 10000
      },
      qr: {
        minLength: 5,
        maxLength: 50,
        scanDelay: 200
      },
      localWsUrl: 'ws://localhost:3001',
      watchdogForceResetMs: 9000,   // if stuck longer than this, force reset
      focusIntervalMs: 100
    };

    // ---------- STATE ----------
    const state = {
      qrBuffer: '',
      lastKeyTime: 0,
      scanTimer: null,
      isProcessing: false,
      stats: { total: 0, success: 0, failed: 0 },
      ws: null,
      lastResetAt: 0,
      lastCycleComplete: null,
    };

    // ---------- DOM ----------
    const D = {
      scanInput: document.getElementById('scanInput'),
      statusCard: document.getElementById('statusCard'),
      scanHistory: document.getElementById('scanHistoryList'),
      totalScans: document.getElementById('totalScans'),
      successScans: document.getElementById('successScans'),
      failedScans: document.getElementById('failedScans'),
      lastResult: document.getElementById('lastResult'),
      wsState: document.getElementById('wsState'),
      wsStatusText: document.getElementById('wsStatusText'),
      uiClientCount: document.getElementById('uiClientCount')
    };

    // ---------- UI helpers ----------
    function updateStatus(icon, text, subtext, type) {
      D.statusCard.className = `status-card ${type || 'ready'}`;
      D.statusCard.innerHTML = `
        <div class="status-icon">${icon}</div>
        <div class="status-text">${text}</div>
        <div class="status-subtext">${subtext || ''}</div>
      `;
    }

    function addScanToHistory(code, success, info) {
      state.stats.total += 1;
      if (success) state.stats.success += 1; else state.stats.failed += 1;
      updateStats();

      const noScans = D.scanHistory.querySelector('.no-scans');
      if (noScans) noScans.remove();

      const item = document.createElement('div');
      item.className = `scan-item ${success ? 'success' : 'error'}`;

      const userName = success && info && (info.name || info.username) ? (info.name || info.username) : (success ? 'Unknown' : '');
      const userHtml = success ? `<div class="scan-user">üë§ User: ${userName}</div>` : '';
      const errHtml = !success ? `<div class="scan-error">‚ùå ${escapeHtml(info || 'Invalid')}</div>` : '';

      item.innerHTML = `
        <div class="scan-code">${success ? '‚úì' : '‚úó'} ${escapeHtml(code)}</div>
        ${userHtml}
        ${errHtml}
        <div class="scan-time">‚è∞ ${new Date().toLocaleString()}</div>
      `;

      D.scanHistory.insertBefore(item, D.scanHistory.firstChild);

      // cap history at 12 items
      const items = D.scanHistory.querySelectorAll('.scan-item');
      if (items.length > 12) items[items.length - 1].remove();
    }

    function updateStats() {
      D.totalScans.textContent = state.stats.total;
      D.successScans.textContent = state.stats.success;
      D.failedScans.textContent = state.stats.failed;
    }

    function clearHistory() {
      D.scanHistory.innerHTML = '<div class="no-scans" style="color:#999;padding:18px;text-align:center">No scans yet. Start scanning QR codes!</div>';
      state.stats = { total: 0, success: 0, failed: 0 };
      updateStats();
    }

    function escapeHtml(s) {
      if (!s) return '';
      return String(s).replace(/[&<>"']/g, (c) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[c]);
    }

    // ---------- Reset & Recovery ----------
    function resetForNextScan(force = false) {
      // Clear buffer & re-enable
      state.qrBuffer = '';
      D.scanInput.value = '';
      state.isProcessing = false;
      D.scanInput.disabled = false;

      updateStatus('üì±', 'Ready to Scan', 'Place QR code near scanner', 'ready');

      // focus after tiny delay to let UI settle
      setTimeout(() => {
        try { D.scanInput.focus(); } catch (e) {}
      }, 80);

      state.lastResetAt = Date.now();
      D.lastResult.textContent = force ? 'Reset (forced or agent signal)' : 'Ready';
    }

    // Force-reset watchdog (periodic)
    setInterval(() => {
      if (D.scanInput.disabled && state.isProcessing) {
        const sinceReset = Date.now() - (state.lastResetAt || 0);
        if (!state.lastResetAt || sinceReset > CONFIG.watchdogForceResetMs) {
          console.warn('Watchdog: forcing reset');
          resetForNextScan(true);
        }
      }
    }, 2500);

    // ---------- Backend validation ----------
    async function validateQRCode(sessionCode) {
      const url = `${CONFIG.backend.url}${CONFIG.backend.validateEndpoint}`;
      try {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), CONFIG.backend.timeoutMs);

        const resp = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sessionCode }),
          signal: controller.signal
        });
        clearTimeout(id);

        if (!resp.ok) {
          const txt = await resp.text().catch(() => '');
          return { valid: false, error: `HTTP ${resp.status} ${txt}` };
        }
        const data = await resp.json();
        return data.success ? { valid: true, user: data.user || data } : { valid: false, error: data.error || 'Invalid QR' };
      } catch (err) {
        if (err.name === 'AbortError') return { valid: false, error: 'Request timeout' };
        return { valid: false, error: err.message || 'Network error' };
      }
    }

    // ---------- Scan processing ----------
    async function processQRCode(qrData) {
      if (state.isProcessing) {
        console.log('Already processing ‚Äî ignoring');
        return;
      }

      state.isProcessing = true;
      D.scanInput.disabled = true;

      const clean = String(qrData).replace(/Enter/gi, '').trim();

      if (clean.length < CONFIG.qr.minLength || clean.length > CONFIG.qr.maxLength) {
        addScanToHistory(clean, false, `Invalid length (${clean.length})`);
        resetForNextScan();
        return;
      }

      if (!/^\d+$/.test(clean)) {
        addScanToHistory(clean, false, 'Must be numeric only');
        resetForNextScan();
        return;
      }

      updateStatus('<div class="loading-spinner"></div>', 'Validating QR Code', `Checking code: ${clean}`, 'validating');
      D.lastResult.textContent = `Validating ${clean} ...`;

      const result = await validateQRCode(clean);

      if (result.valid) {
        addScanToHistory(clean, true, result.user || {});
        updateStatus('üöÄ', 'Gate Opening', 'Place your item ‚Äî agent will handle cycle', 'success');
        D.lastResult.textContent = `Validated: ${clean} ‚Äî waiting for agent to complete cycle`;

        // Don't reset here ‚Äî agent will send resetReady or cycleComplete (local WS)
        // But put a fallback: if agent doesn't respond in watchdogTimeout, force reset
        const fallback = setTimeout(() => {
          const since = Date.now() - (state.lastResetAt || 0);
          if (!state.lastResetAt || since > CONFIG.watchdogForceResetMs) {
            console.warn('No reset from agent ‚Äî performing local fallback reset');
            resetForNextScan(true);
          }
        }, CONFIG.watchdogForceResetMs + 2000);

        // save fallback so we can clear when reset arrives
        state._pendingFallback = fallback;
      } else {
        addScanToHistory(clean, false, result.error);
        updateStatus('‚ùå', 'Validation Failed', result.error || 'Invalid QR', 'error');
        D.lastResult.textContent = `Validation failed: ${result.error || 'Invalid'}`;
        setTimeout(() => resetForNextScan(false), 1800);
      }
    }

    // ---------- Keyboard capture (scanner = keyboard) ----------
    D.scanInput.addEventListener('keydown', (ev) => {
      // If disabled, ignore keys
      if (D.scanInput.disabled) {
        ev.preventDefault();
        return;
      }

      const now = Date.now();
      const diff = now - (state.lastKeyTime || 0);

      if (diff > 100) state.qrBuffer = '';
      state.lastKeyTime = now;

      if (ev.key === 'Enter') {
        ev.preventDefault();
        if (state.scanTimer) clearTimeout(state.scanTimer);
        if (state.qrBuffer && state.qrBuffer.length > 0) {
          updateStatus('üîÑ', 'Processing Scan', 'Please wait...', 'scanning');
          processQRCode(state.qrBuffer);
        }
      } else if (ev.key.length === 1) {
        state.qrBuffer += ev.key;
        D.scanInput.value = state.qrBuffer;
        if (state.scanTimer) clearTimeout(state.scanTimer);
        if (state.qrBuffer.length >= CONFIG.qr.minLength) {
          state.scanTimer = setTimeout(() => {
            if (!state.isProcessing && state.qrBuffer.length > 0) {
              updateStatus('üîÑ', 'Processing Scan', 'Please wait...', 'scanning');
              processQRCode(state.qrBuffer);
            }
          }, CONFIG.qr.scanDelay);
        }
      } else {
        // ignore control keys
      }
    });

    // ---------- Focus management ----------
    function ensureFocus() {
      if (state.isProcessing) return;
      if (document.activeElement !== D.scanInput) {
        try { D.scanInput.focus(); } catch (e) {}
      }
    }
    setInterval(ensureFocus, CONFIG.focusIntervalMs);

    // ---------- Local WebSocket (connect to agent) ----------
    function connectLocalWs() {
      try {
        D.wsState.textContent = 'connecting...';
        D.wsState.style.color = '#f59e0b';
        D.wsStatusText.textContent = 'connecting...';

        const ws = new WebSocket(CONFIG.localWsUrl);

        ws.addEventListener('open', () => {
          console.log('Connected to agent local WS');
          D.wsState.textContent = 'connected';
          D.wsState.style.color = '#2e7d32';
          D.wsStatusText.textContent = 'connected (local)';
          // show number of connected clients if agent broadcasts this (optional)
        });

        ws.addEventListener('message', (ev) => {
          try {
            const data = JSON.parse(ev.data);
            handleAgentMessage(data);
          } catch (err) {
            console.warn('Invalid WS payload', err);
          }
        });

        ws.addEventListener('close', () => {
          console.warn('Local WS closed ‚Äî reconnect in 2s');
          D.wsState.textContent = 'disconnected';
          D.wsState.style.color = '#d32f2f';
          D.wsStatusText.textContent = 'disconnected ‚Äî reconnecting';
          setTimeout(connectLocalWs, 2000);
        });

        ws.addEventListener('error', (err) => {
          console.warn('Local WS error', err && (err.message || err));
          D.wsState.textContent = 'error';
          D.wsState.style.color = '#d32f2f';
          D.wsStatusText.textContent = 'error';
          ws.close();
        });

        state.ws = ws;
      } catch (err) {
        console.warn('connectLocalWs exception', err);
        setTimeout(connectLocalWs, 2000);
      }
    }

    function handleAgentMessage(msg) {
      if (!msg || !msg.type) return;

      if (msg.type === 'resetReady') {
        // agent told us to re-enable input (cycle finished or ready)
        console.log('Agent -> resetReady received');
        D.lastResult.textContent = 'Agent signalled ready';
        if (state._pendingFallback) { clearTimeout(state._pendingFallback); state._pendingFallback = null; }
        resetForNextScan(true);
      }

      if (msg.type === 'cycleComplete') {
        console.log('Agent -> cycleComplete', msg.payload);
        state.lastCycleComplete = msg.payload || null;
        // show info, reset input
        D.lastResult.textContent = 'Cycle complete ‚Äî ' + (msg.payload && msg.payload.success ? 'success' : 'failure');
        if (state._pendingFallback) { clearTimeout(state._pendingFallback); state._pendingFallback = null; }
        // update UI history with cycle result if you want
        // force reset for next scan
        resetForNextScan(true);
      }

      if (msg.type === 'ready') {
        // agent handshake
        D.lastResult.textContent = 'Agent connected';
      }
    }

    // ---------- Simulation helpers for local testing ----------
    window.simulateValid = function simulateValid() {
      const code = String(Math.floor(10000000 + Math.random() * 89999999));
      D.scanInput.value = code;
      state.qrBuffer = code;
      processQRCode(code);
    };

    window.simulateInvalid = function simulateInvalid() {
      const code = 'INVALID-' + Math.random().toString(36).slice(2,8).toUpperCase();
      D.scanInput.value = code;
      state.qrBuffer = code;
      processQRCode(code);
    };

    // ---------- Expose clearHistory to global scope ----------
    window.clearHistory = clearHistory;

    // ---------- Initialize ----------
    (function init() {
      updateStatus('üì±', 'Ready to Scan', 'Place QR code near scanner', 'ready');
      D.scanInput.focus();
      connectLocalWs();
      // ensure focus after short delay on load
      setTimeout(() => { try { D.scanInput.focus(); } catch (e) {} }, 120);
    })();
  })();
  </script>
</body>
</html>
